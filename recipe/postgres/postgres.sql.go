// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: postgres.sql

package postgres

import (
	"context"
	"time"
)

const allIngredientsByNames = `-- name: AllIngredientsByNames :many
SELECT id, name
FROM ingredients
WHERE name = ANY ($1::text[])
`

func (q *Queries) AllIngredientsByNames(ctx context.Context, names []string) ([]Ingredient, error) {
	rows, err := q.db.Query(ctx, allIngredientsByNames, names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ingredient{}
	for rows.Next() {
		var i Ingredient
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allRecipeIngredients = `-- name: AllRecipeIngredients :many
SELECT id, name, recipe_order, recipe_id, ingredient_id, unit, quantity, note
FROM ingredients
         JOIN recipe_ingredients ri on ingredients.id = ri.ingredient_id
WHERE recipe_id = ANY ($1::int[])
ORDER BY recipe_id, recipe_order
`

type AllRecipeIngredientsRow struct {
	ID           int32
	Name         string
	RecipeOrder  int32
	RecipeID     int32
	IngredientID int32
	Unit         string
	Quantity     float32
	Note         string
}

func (q *Queries) AllRecipeIngredients(ctx context.Context, ids []int32) ([]AllRecipeIngredientsRow, error) {
	rows, err := q.db.Query(ctx, allRecipeIngredients, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllRecipeIngredientsRow{}
	for rows.Next() {
		var i AllRecipeIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RecipeOrder,
			&i.RecipeID,
			&i.IngredientID,
			&i.Unit,
			&i.Quantity,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allRecipeSummaries = `-- name: AllRecipeSummaries :many
SELECT recipes.id, recipes.name, recipes.description, images.url
FROM recipes
         LEFT JOIN images on recipes.thumbnail_id = images.id
WHERE ($1::int[] IS NULL OR recipes.id = ANY ($1::int[]))
ORDER BY recipes.id DESC
LIMIT $3 OFFSET $2
`

type AllRecipeSummariesParams struct {
	Ids    []int32
	Offset int32
	Limit  int32
}

type AllRecipeSummariesRow struct {
	ID          int32
	Name        string
	Description string
	Url         *string
}

func (q *Queries) AllRecipeSummaries(ctx context.Context, arg AllRecipeSummariesParams) ([]AllRecipeSummariesRow, error) {
	rows, err := q.db.Query(ctx, allRecipeSummaries, arg.Ids, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllRecipeSummariesRow{}
	for rows.Next() {
		var i AllRecipeSummariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allRecipeTags = `-- name: AllRecipeTags :many
SELECT id, name, recipe_order, recipe_id, tag_id
FROM tags
         JOIN recipe_tags rt on tags.id = rt.tag_id
WHERE recipe_id = ANY ($1::int[])
ORDER BY recipe_id, recipe_order
`

type AllRecipeTagsRow struct {
	ID          int32
	Name        string
	RecipeOrder int32
	RecipeID    int32
	TagID       int32
}

func (q *Queries) AllRecipeTags(ctx context.Context, ids []int32) ([]AllRecipeTagsRow, error) {
	rows, err := q.db.Query(ctx, allRecipeTags, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllRecipeTagsRow{}
	for rows.Next() {
		var i AllRecipeTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RecipeOrder,
			&i.RecipeID,
			&i.TagID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allTagsByNames = `-- name: AllTagsByNames :many
SELECT id, name
FROM tags
WHERE name = ANY ($1::text[])
`

func (q *Queries) AllTagsByNames(ctx context.Context, names []string) ([]Tag, error) {
	rows, err := q.db.Query(ctx, allTagsByNames, names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countRecipeSummaries = `-- name: CountRecipeSummaries :one
SELECT count(*)
FROM recipes
`

func (q *Queries) CountRecipeSummaries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRecipeSummaries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIngredient = `-- name: CreateIngredient :one
INSERT INTO ingredients (name)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateIngredient(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, createIngredient, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createNutrition = `-- name: CreateNutrition :exec
INSERT INTO recipe_nutrition (recipe_id, calories, fat, carbs, protein)
VALUES ($1, $2, $3, $4, $5)
`

type CreateNutritionParams struct {
	RecipeID int32
	Calories float32
	Fat      float32
	Carbs    float32
	Protein  float32
}

func (q *Queries) CreateNutrition(ctx context.Context, arg CreateNutritionParams) error {
	_, err := q.db.Exec(ctx, createNutrition,
		arg.RecipeID,
		arg.Calories,
		arg.Fat,
		arg.Carbs,
		arg.Protein,
	)
	return err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (name, description, instructions_markdown, thumbnail_id,
                     cook_time_seconds, preparation_time_seconds, source, owner_id, servings)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type CreateRecipeParams struct {
	Name                   string
	Description            string
	InstructionsMarkdown   string
	ThumbnailID            *int32
	CookTimeSeconds        int32
	PreparationTimeSeconds int32
	Source                 string
	OwnerID                int32
	Servings               int32
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.Name,
		arg.Description,
		arg.InstructionsMarkdown,
		arg.ThumbnailID,
		arg.CookTimeSeconds,
		arg.PreparationTimeSeconds,
		arg.Source,
		arg.OwnerID,
		arg.Servings,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createRecipeImage = `-- name: CreateRecipeImage :one
INSERT INTO images (url)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateRecipeImage(ctx context.Context, url string) (int32, error) {
	row := q.db.QueryRow(ctx, createRecipeImage, url)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :exec
INSERT INTO recipe_ingredients (recipe_order, recipe_id, ingredient_id, unit, quantity, note)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateRecipeIngredientParams struct {
	RecipeOrder  int32
	RecipeID     int32
	IngredientID int32
	Unit         string
	Quantity     float32
	Note         string
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) error {
	_, err := q.db.Exec(ctx, createRecipeIngredient,
		arg.RecipeOrder,
		arg.RecipeID,
		arg.IngredientID,
		arg.Unit,
		arg.Quantity,
		arg.Note,
	)
	return err
}

const createRecipeTag = `-- name: CreateRecipeTag :exec
INSERT INTO recipe_tags (recipe_order, recipe_id, tag_id)
VALUES ($1, $2, $3)
`

type CreateRecipeTagParams struct {
	RecipeOrder int32
	RecipeID    int32
	TagID       int32
}

func (q *Queries) CreateRecipeTag(ctx context.Context, arg CreateRecipeTagParams) error {
	_, err := q.db.Exec(ctx, createRecipeTag, arg.RecipeOrder, arg.RecipeID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateTag(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteRecipeIngredients = `-- name: DeleteRecipeIngredients :exec
DELETE
FROM recipe_ingredients
WHERE recipe_id = $1
`

func (q *Queries) DeleteRecipeIngredients(ctx context.Context, recipeID int32) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredients, recipeID)
	return err
}

const deleteRecipeTags = `-- name: DeleteRecipeTags :exec
DELETE
FROM recipe_tags
WHERE recipe_id = $1
`

func (q *Queries) DeleteRecipeTags(ctx context.Context, recipeID int32) error {
	_, err := q.db.Exec(ctx, deleteRecipeTags, recipeID)
	return err
}

const getFullRecipe = `-- name: GetFullRecipe :one
SELECT recipes.id, name, description, instructions_markdown, thumbnail_id, servings, cook_time_seconds, preparation_time_seconds, source, created_at, updated_at, owner_id, recipe_id, calories, fat, carbs, protein, im.id, url
FROM recipes
         JOIN recipe_nutrition rn on recipes.id = rn.recipe_id
         LEFT JOIN images im on recipes.thumbnail_id = im.id
WHERE recipes.id = $1
LIMIT 1
`

type GetFullRecipeRow struct {
	ID                     int32
	Name                   string
	Description            string
	InstructionsMarkdown   string
	ThumbnailID            *int32
	Servings               int32
	CookTimeSeconds        int32
	PreparationTimeSeconds int32
	Source                 string
	CreatedAt              *time.Time
	UpdatedAt              *time.Time
	OwnerID                int32
	RecipeID               int32
	Calories               float32
	Fat                    float32
	Carbs                  float32
	Protein                float32
	ID_2                   *int32
	Url                    *string
}

func (q *Queries) GetFullRecipe(ctx context.Context, id int32) (GetFullRecipeRow, error) {
	row := q.db.QueryRow(ctx, getFullRecipe, id)
	var i GetFullRecipeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.InstructionsMarkdown,
		&i.ThumbnailID,
		&i.Servings,
		&i.CookTimeSeconds,
		&i.PreparationTimeSeconds,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.RecipeID,
		&i.Calories,
		&i.Fat,
		&i.Carbs,
		&i.Protein,
		&i.ID_2,
		&i.Url,
	)
	return i, err
}

const updateNutrition = `-- name: UpdateNutrition :exec
UPDATE recipe_nutrition
SET calories = $1,
    fat      = $2,
    carbs    = $3,
    protein  = $4
WHERE recipe_id = $5
`

type UpdateNutritionParams struct {
	Calories float32
	Fat      float32
	Carbs    float32
	Protein  float32
	RecipeID int32
}

func (q *Queries) UpdateNutrition(ctx context.Context, arg UpdateNutritionParams) error {
	_, err := q.db.Exec(ctx, updateNutrition,
		arg.Calories,
		arg.Fat,
		arg.Carbs,
		arg.Protein,
		arg.RecipeID,
	)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE recipes
SET name                     = $1,
    description              = $2,
    instructions_markdown    = $3,
    thumbnail_id             = $4,
    cook_time_seconds        = $5,
    preparation_time_seconds = $6,
    source                   = $7,
    updated_at               = $8,
    servings                 = $9
WHERE id = $10
`

type UpdateRecipeParams struct {
	Name                   string
	Description            string
	InstructionsMarkdown   string
	ThumbnailID            *int32
	CookTimeSeconds        int32
	PreparationTimeSeconds int32
	Source                 string
	UpdatedAt              *time.Time
	Servings               int32
	ID                     int32
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe,
		arg.Name,
		arg.Description,
		arg.InstructionsMarkdown,
		arg.ThumbnailID,
		arg.CookTimeSeconds,
		arg.PreparationTimeSeconds,
		arg.Source,
		arg.UpdatedAt,
		arg.Servings,
		arg.ID,
	)
	return err
}
